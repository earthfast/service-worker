<!doctype html>
<html lang="en">

<head>
  <link rel="stylesheet" href="/earthfast/styles/main.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body class="hidden regular-flow">
  <div id="content">
    <div class="logo">
      <img id="logo" class="logo__image" src="/earthfast/images/earth-fast-logo.svg" alt="Earth Fast">
      <h2 class="logo__title">EarthFast</h2>
    </div>
    <div class="description-container">
      <div class="description-text">
        <span class="securely-text" id="description-text">Securely loading</span>
        <span id="domain"></span>
      </div>
      <div id="spinner" class="spinner"></div>
    </div>

    <!-- Developer Tools Notice -->
    <div id="dev-tools-notice" class="dev-tools-notice">
      <p>Please open Developer Tools (F12) and go to the Network tab before continuing.</p>
      <p>Once you have the Network tab open, click the button below:</p>
      <button id="start-loading-button">Start Loading</button>
    </div>

    <!-- Developer Tools Instructions (only visible when the notice is not active) -->
    <div class="dev-tools-instructions">
      <p class="help-text text-center">To follow along with the loading process, open your browser's developer tools
        (F12) and go to
        the Network tab.</p>
    </div>

    <!-- New container for stages -->
    <div class="stages-container" id="stages-container">
      <!-- Stage 1: Manifest Loading -->
      <div class="stage" id="stage-manifest">
        <div class="stage-header stage-toggle-header">
          <div class="stage-icon pending" id="stage-manifest-icon">
            <span>1</span>
          </div>
          <div class="stage-title">Asset Manifest Consensus</div>
          <div class="stage-progress" id="stage-manifest-progress">
            <div class="stage-progress-text">0/0 nodes</div>
          </div>
          <div class="stage-spinner"></div>
          <div class="stage-time" id="stage-manifest-time"></div>
          <div class="stage-toggle">▼</div>
        </div>
        <div class="stage-content">
          <div id="stage-manifest-content">
            <p>Waiting for asset manifest consensus from content nodes...</p>
            <p class="help-text">Tip: Search for "earthfast.json" in the Network panel to see manifest responses from
              each node.</p>
            <ul class="manifest-list" id="manifest-nodes-list">
              <!-- Manifest nodes will be loaded dynamically -->
            </ul>
          </div>
        </div>
      </div>

      <!-- Stage 2: index.html loaded -->
      <div class="stage" id="stage-index">
        <div class="stage-header stage-toggle-header">
          <div class="stage-icon pending" id="stage-index-icon">
            <span>2</span>
          </div>
          <div class="stage-title">index.html Loaded</div>
          <div class="stage-spinner"></div>
          <div class="stage-time" id="stage-index-time"></div>
          <div class="stage-toggle">▼</div>
        </div>
        <div class="stage-content">
          <div id="stage-index-content">
            <p>Loading index.html from content nodes...</p>
            <p class="help-text">Tip: Search for "index.html" in the Network panel to see the page load.</p>
          </div>
        </div>
      </div>

      <!-- Stage 3: Request Table -->
      <div class="stage" id="stage-resources">
        <div class="stage-header stage-toggle-header">
          <div class="stage-icon pending" id="stage-resources-icon">
            <span>3</span>
          </div>
          <div class="stage-title">Network Requests</div>
          <div class="stage-spinner"></div>
          <div class="stage-time" id="stage-resources-time"></div>
          <div class="stage-toggle">▼</div>
        </div>
        <div class="stage-content">
          <div id="stage-resources-content">
            <p>Loading website resources from content nodes...</p>
            <p class="help-text">Tip: Use these filters in the Network panel to see different types of requests:</p>
            <ul class="filter-list">
              <li><span class="filter-type">CSS:</span> <code class="filter-code">*.css</code></li>
              <li><span class="filter-type">JavaScript:</span> <code class="filter-code">*.js</code></li>
              <li><span class="filter-type">Images:</span> <code class="filter-code">*.svg, *.png, *.jpg</code></li>
            </ul>
            <div class="table-container">
              <table class="requests-table" id="requests-table">
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Time</th>
                    <th>Resource</th>
                    <th>Node</th>
                    <th>Status</th>
                  </tr>
                </thead>
                <tbody id="requests-table-body">
                  <!-- Requests will be loaded dynamically -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Stage 4: Site Ready -->
      <div class="stage" id="stage-ready">
        <div class="stage-header stage-toggle-header">
          <div class="stage-icon pending" id="stage-ready-icon">
            <span>4</span>
          </div>
          <div class="stage-title">Website Ready</div>
          <div class="stage-spinner"></div>
          <div class="stage-time" id="stage-ready-time"></div>
          <div class="stage-toggle">▼</div>
        </div>
        <div class="stage-content">
          <div id="stage-ready-content">
            <div id="stage-ready-message"></div>
            <button id="stage-ready-button" class="continue-button">Continue to website</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Configuration
    const config = {
      // Service worker configuration
      serviceWorker: {
        path: '/earthfast-sw.js',
        scope: '/'
      },

      // Request tracking configuration
      requests: {
        maxRequests: 50,
        minSuccessfulResources: 5
      },

      // Stage configuration
      stages: {
        sequence: ['stage-manifest', 'stage-index', 'stage-resources', 'stage-ready'],
        manifest: {
          minSuccessNodes: 1 // Minimum number of successful nodes for consensus
        }
      },

      // UI configuration
      ui: {
        spinner: {
          defaultDisplay: localStorage.getItem('showSpinner') !== 'false'
        },
        button: {
          ready: {
            defaultDisplay: 'block',
            disabledOpacity: '0.5',
            enabledOpacity: '1'
          }
        }
      },

      // Resource types
      resources: {
        manifest: ['earthfast.json', 'armada.json'],
        index: ['index.html', '/index.html'],
        ignored: ['nodes', '.DS_Store'],
        ignoredMethods: ['OPTIONS']
      }
    };

    const urlParams = new URLSearchParams(window.location.search);
    const isSecureViewer = urlParams.has('secure_viewer');

    const showSpinner = config.ui.spinner.defaultDisplay;
    const serviceWorker = config.serviceWorker.path;
    const requestsLog = null;
    const requestsStats = null;
    const stageReadyButton = document.getElementById('stage-ready-button');
    const devToolsInstructions = document.querySelector('.dev-tools-instructions');

    // Global state
    let readyToLoad = false;
    let hasRedirected = false;  // New flag to prevent infinite loops

    // Request counter for generating unique IDs
    let requestCounter = 0;

    // Track the requests for logging
    let requests = [];
    const maxRequests = config.requests.maxRequests;  // Maximum number of requests to display

    // Stats for requests to nodes
    const requestStats = {
      total: 0,
      success: 0,
      failed: 0,
      nodes: new Set()
    };

    // Node and manifest registry
    const manifestNodes = {
      total: 0,
      success: 0,
      nodes: {}
    };

    // Stage states
    const stages = {};
    config.stages.sequence.forEach(stageId => {
      stages[stageId] = { started: false, completed: false, startTime: null, endTime: null };
    });

    let preloadingComplete = false;

    // Utility functions
    const utils = {
      formatTimestamp() {
        const now = new Date();
        return `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(
          2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
      },

      formatRequestTimestamp(timestamp) {
        const date = new Date(timestamp);
        return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(
          2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
      },

      formatTimeDuration(startTime, endTime) {
        if (!startTime || !endTime) return '';
        const duration = Math.round((endTime - startTime) / 1000);
        if (duration < 60) {
          return `${duration}s`;
        } else {
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          return `${minutes}m ${seconds}s`;
        }
      }
    };

    // Stage management
    const stageManager = {
      // Update visual state of a stage
      updateStageStatus(stageId, status, message = null) {
        const stage = document.getElementById(stageId);
        const icon = document.getElementById(`${stageId}-icon`);
        const content = document.getElementById(`${stageId}-content`);
        const timeEl = document.getElementById(`${stageId}-time`);

        // Remove previous classes from stage and icon
        stage.classList.remove('running');
        icon.classList.remove('pending', 'running', 'success', 'error');

        // If the stage is starting
        if (status === 'running' && !stages[stageId].started) {
          stages[stageId].started = true;
          stages[stageId].startTime = Date.now();
          icon.classList.add('running');
          stage.classList.add('expanded', 'running');

          // Adjust height automatically
          const contentWrapper = stage.querySelector('.stage-content');
          contentWrapper.style.height = 'auto';
        }

        // Update content if a message is provided, but handle stage-ready differently
        if (message) {
          if (stageId === 'stage-ready') {
            const messageDiv = document.getElementById('stage-ready-message');
            if (messageDiv) {
              messageDiv.innerHTML = message;
            }
          } else {
            content.innerHTML = message;
          }
          this.updateExpandedSectionHeights();
        }

        // Update icon according to status
        icon.classList.add(status);

        // If the stage is completed
        if ((status === 'success' || status === 'error') && !stages[stageId].completed) {
          stages[stageId].completed = true;
          stages[stageId].endTime = Date.now();
          timeEl.textContent = utils.formatTimeDuration(stages[stageId].startTime, stages[stageId].endTime);
        }
      },

      // Get the next stage in the sequence
      getNextStage(currentStageId) {
        const currentIndex = config.stages.sequence.indexOf(currentStageId);
        if (currentIndex !== -1 && currentIndex < config.stages.sequence.length - 1) {
          return config.stages.sequence[currentIndex + 1];
        }
        return null;
      },

      // Update heights of all expanded sections
      updateExpandedSectionHeights() {
        document.querySelectorAll('.stage.expanded').forEach(stage => {
          const content = stage.querySelector('.stage-content');
          if (content) {
            content.style.height = 'auto';
          }
        });
      },

      // Update all stage statuses
      updateAllStages() {
        this.updateManifestStage();
        this.updateIndexStage();
        this.updateResourcesStage();
        this.updateReadyStage();
      },

      updateManifestStage() {
        const hasManifestRequests = requests.some(req =>
          req.isTrackedRequest &&
          req.resource &&
          config.resources.manifest.includes(req.resource)
        );

        if (hasManifestRequests && !stages['stage-manifest'].started) {
          this.updateStageStatus('stage-manifest', 'running');
        }

        if (manifestNodes.success >= Math.floor(manifestNodes.total / 2) + 1 &&
          stages['stage-manifest'].started &&
          !stages['stage-manifest'].completed) {
          this.updateStageStatus('stage-manifest', 'success');
        }
      },

      updateIndexStage() {
        const indexRequests = requests.filter(req =>
          req.isTrackedRequest &&
          req.rawRequest &&
          config.resources.index.includes(req.rawRequest.resource)
        );

        if (indexRequests.length > 0 && !stages['stage-index'].started) {
          this.updateStageStatus('stage-index', 'running');
        }

        const successfulIndexRequest = indexRequests.find(req => req.rawRequest.success);
        if (successfulIndexRequest && !stages['stage-index'].completed) {
          this.updateStageStatus(
            'stage-index',
            'success',
            '<p>Successfully loaded index.html from content nodes.</p>'
          );
        }
      },

      updateResourcesStage() {
        const resourceRequests = requests.filter(req =>
          req.isTrackedRequest &&
          req.rawRequest &&
          !config.resources.ignored.includes(req.rawRequest.resource) &&
          !req.rawRequest.url.endsWith('/index.html')
        );

        if (resourceRequests.length > 0 && !stages['stage-resources'].started) {
          this.updateStageStatus('stage-resources', 'running');
        }

        const successfulResources = resourceRequests.filter(req =>
          req.rawRequest &&
          req.rawRequest.status === 200
        ).length;

        if (successfulResources >= config.requests.minSuccessfulResources && !stages['stage-resources'].completed) {
          this.updateStageStatus(
            'stage-resources',
            'success',
            `<p>Successfully loaded ${successfulResources} resources from content nodes.</p>
             <p class="help-text">Tip: Use these filters in the Network panel to see different types of requests:</p>
             <ul class="filter-list">
               <li><span class="filter-type">CSS:</span> <code class="filter-code">*.css</code></li>
               <li><span class="filter-type">JavaScript:</span> <code class="filter-code">*.js</code></li>
               <li><span class="filter-type">Images:</span> <code class="filter-code">*.svg, *.png, *.jpg</code></li>
             </ul>
             <div class="table-container">
               <table class="requests-table" id="requests-table">
                 <thead>
                   <tr>
                     <th>ID</th>
                     <th>Time</th>
                     <th>Resource</th>
                     <th>Node</th>
                     <th>Status</th>
                   </tr>
                 </thead>
                 <tbody id="requests-table-body">
                 </tbody>
               </table>
             </div>`
          );

          if (!stages['stage-ready'].started) {
            this.updateStageStatus('stage-ready', 'running');
          }
        }
      },

      updateReadyStage() {
        const allPreviousStagesComplete =
          stages['stage-manifest'].completed &&
          stages['stage-index'].completed &&
          stages['stage-resources'].completed;

        if (allPreviousStagesComplete) {
          const messageDiv = document.getElementById('stage-ready-message');
          if (messageDiv) {
            messageDiv.innerHTML = '<p>All resources have been loaded successfully.</p>';
          }
          this.updateStageStatus('stage-ready', 'success');
          document.getElementById('spinner').classList.add('hidden')
          document.getElementById('description-text').innerHTML = 'Securely loaded';
        }

        if (isSecureViewer) {
          const readyButton = document.getElementById('stage-ready-button');
          if (readyButton) {
            readyButton.style.display = config.ui.button.ready.defaultDisplay;
            readyButton.disabled = !allPreviousStagesComplete;
            readyButton.style.opacity = allPreviousStagesComplete ? config.ui.button.ready.enabledOpacity : config.ui.button.ready.disabledOpacity;
            readyButton.style.cursor = allPreviousStagesComplete ? 'pointer' : 'not-allowed';
          }
        }
      }
    };

    // Request tracking management
    const requestTracker = {
      // Add a request to the log
      addRequest(type, message, isError = false) {
        const timestamp = utils.formatTimestamp();
        requests.unshift({ timestamp, type, message, isError });

        // Keep only the latest maxRequests
        if (requests.length > config.requests.maxRequests) {
          requests.pop();
        }

        this.updateRequestsLog();
      },

      // Add a tracked request from the service worker
      addRequestFromTracker(request) {
        try {
          const requestId = request.id || this.generateRequestId();

          // Update stats
          requestStats.total++;
          if (request.success) {
            requestStats.success++;
          } else {
            requestStats.failed++;
          }
          requestStats.nodes.add(request.node);

          // Add to requests array
          requests.unshift({
            id: requestId,
            timestamp: utils.formatRequestTimestamp(request.timestamp),
            type: request.success ? 'success' : 'error',
            message: this.formatTrackedRequest(request),
            isError: !request.success,
            isTrackedRequest: true,
            rawRequest: request
          });

          // Keep only the latest maxRequests
          if (requests.length > config.requests.maxRequests) {
            requests.pop();
          }

          // Update UI
          this.updateRequestsTable();

          // Handle manifest
          if (request.resource === 'earthfast.json' || request.resource === 'armada.json') {
            this.updateManifestRequest(request, requestId);
          }

          // Update logs and stats
          this.updateRequestsLog();
          this.updateRequestStats();

        } catch (error) {
          console.error('Error processing request:', error);
        }
      },

      // Generate a unique ID for each request
      generateRequestId() {
        requestCounter++;
        return `req-${requestCounter.toString().padStart(4, '0')}`;
      },

      // Format a tracked request for display
      formatTrackedRequest(request) {
        let statusClass = request.success ? 'status-ok' : 'status-error';
        let statusText = request.status ? request.status : (request.success ? 'OK' : 'Failed');

        return `<div class="request-details">
                    <span>
                      <span class="node-info">${request.node}</span> ›
                      <span class="resource-info">${request.resource || 'unknown'}</span>
                    </span>
                    <span class="request-status ${statusClass}">${statusText}</span>
                  </div>`;
      },

      // Update the request stats display
      updateRequestStats() {
        if (!requestsStats) return;
        requestsStats.innerHTML = `
            <div>Total: ${requestStats.total} | Success: ${requestStats.success} | Failed: ${requestStats.failed} | Nodes: ${requestStats.nodes.size}</div>
          `;
      },

      // Update the requests log display
      updateRequestsLog() {
        if (!requestsLog) return;
        requestsLog.innerHTML = '';

        requests.forEach(req => {
          const item = document.createElement('div');
          item.classList.add('request-item');
          if (req.isError) {
            item.classList.add('error');
          } else if (req.type === 'success') {
            item.classList.add('success');
          }

          const timestamp = document.createElement('span');
          timestamp.classList.add('timestamp');
          timestamp.textContent = req.timestamp;

          item.appendChild(timestamp);

          // For tracked requests, use innerHTML to include the formatted HTML
          if (req.isTrackedRequest) {
            const contentSpan = document.createElement('span');
            contentSpan.innerHTML = req.message;
            item.appendChild(contentSpan);
          } else {
            item.appendChild(document.createTextNode(`[${req.type}] ${req.message}`));
          }

          requestsLog.appendChild(item);
        });
      },

      // Update the requests table
      updateRequestsTable() {
        const tableBody = document.getElementById('requests-table-body');

        // Clear table
        tableBody.innerHTML = '';

        // Filter requests for the table
        const filteredRequests = requests.filter(
          req => req.isTrackedRequest &&
            req.rawRequest &&
            !config.resources.ignored.includes(req.rawRequest.resource) &&
            !config.resources.ignoredMethods.includes(req.rawRequest.method) &&
            typeof req.rawRequest.status === 'number' &&
            !req.rawRequest.resource.endsWith('.DS_Store')
        );

        // Group by resource and keep the most recent successful, or the most recent if none are successful
        const uniqueRequestsMap = new Map();
        filteredRequests.forEach(req => {
          const key = req.rawRequest.resource;
          if (!uniqueRequestsMap.has(key)) {
            uniqueRequestsMap.set(key, req);
          } else {
            const existing = uniqueRequestsMap.get(key);
            // Prefer the most recent successful
            if (req.rawRequest.success && !existing.rawRequest.success) {
              uniqueRequestsMap.set(key, req);
            } else if (req.rawRequest.success === existing.rawRequest.success) {
              // If both are successful or both failed, keep the most recent
              if (req.rawRequest.timestamp > existing.rawRequest.timestamp) {
                uniqueRequestsMap.set(key, req);
              }
            }
          }
        });
        const resourceRequests = Array.from(uniqueRequestsMap.values());

        // If no requests, show message
        if (resourceRequests.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
              <td colspan="5" style="text-align: center; padding: 20px;">
                No requests detected yet.
                Requests will appear automatically when made.
              </td>
            `;
          tableBody.appendChild(tr);

          // Update expanded section heights
          stageManager.updateExpandedSectionHeights();
          return;
        }

        // Limit to the 50 most recent requests
        const limitedRequests = resourceRequests.slice(0, 50);

        // Add rows to the table
        limitedRequests.forEach(req => {
          const tr = document.createElement('tr');
          const request = req.rawRequest;

          // Generate ID if it doesn't exist
          if (!req.id) {
            req.id = this.generateRequestId();
          }

          const statusClass = request.success ? 'status-ok' : 'status-error';
          const statusText = request.status ? request.status : (request.success ? 'OK' : 'Failed');

          tr.innerHTML = `
              <td><span class="request-id">${req.id}</span></td>
              <td>${req.timestamp}</td>
              <td><span class="resource-info">${request.resource || 'unknown'}</span></td>
              <td><span class="node-info">${request.node}</span></td>
              <td><span class="request-status ${statusClass}">${statusText}</span></td>
            `;

          tableBody.appendChild(tr);
        });

        // Update expanded section heights after adding new content
        stageManager.updateExpandedSectionHeights();

        // If there are enough successful requests, consider the stage complete
        const successfulRequests =
          resourceRequests.filter(req => req.rawRequest && req.rawRequest.success);
        if (successfulRequests.length >= config.requests.minSuccessfulResources && !stages['stage-ready'].started) {
          stageManager.updateStageStatus('stage-resources', 'success');
          stageManager.updateStageStatus('stage-ready', 'running');

          // Show button to continue
          document.getElementById('stage-ready-button').style.display = config.ui.button.ready.defaultDisplay;

          // Connect event to new button
          document.getElementById('stage-ready-button').addEventListener('click', () => {
            if (!isSecureViewer) {
              readyToLoad = true;
              location.reload();
            } else {
              // In secure viewer mode, just remove the parameter and redirect
              const url = new URL(window.location.href);
              url.searchParams.delete('secure_viewer');
              window.location.href = url.toString();
            }
          });
        }
      },

      // Update manifest request information
      updateManifestRequest(request, requestId) {
        if (!stages['stage-manifest'].started) {
          stageManager.updateStageStatus('stage-manifest', 'running');
        }

        const nodeId = request.node;

        // Register this node if it doesn't exist
        if (!manifestNodes.nodes[nodeId]) {
          manifestNodes.nodes[nodeId] = {
            status: request.success ? 'success' : 'error',
            statusCode: request.status || 0,
            hash: null,
            requestId: requestId
          };
          manifestNodes.total++;

          if (request.success) {
            manifestNodes.success++;
          }
        }

        // Update the progress in the UI
        const progressEl = document.getElementById('stage-manifest-progress');
        progressEl.innerHTML = `<div class="stage-progress-text">${manifestNodes.success}/${manifestNodes.total} nodes</div>`;

        // Update the manifest nodes list
        this.updateManifestNodesList();

        // If all nodes have responded, consider the stage complete
        if (Object.keys(manifestNodes.nodes).length >= requestStats.nodes.size) {
          if (manifestNodes.success >= config.stages.manifest.minSuccessNodes) {
            stageManager.updateStageStatus('stage-manifest', 'success');

            // Start the next resource loading stage
            stageManager.updateStageStatus('stage-resources', 'running');
          } else {
            stageManager.updateStageStatus(
              'stage-manifest', 'error',
              '<p>Failed to reach consensus on manifest from content nodes.</p>');
          }
        }
      },

      // Update the list of nodes that provided the manifest
      updateManifestNodesList() {
        const listEl = document.getElementById('manifest-nodes-list');
        listEl.innerHTML = '';

        Object.entries(manifestNodes.nodes).forEach(([nodeId, data]) => {
          const li = document.createElement('li');
          li.className = 'manifest-item';

          const statusClass = data.status === 'success' ? 'status-ok' : 'status-error';
          const statusText = data.status === 'success' ? 'OK' : 'Failed';

          li.innerHTML = `
              <span class="manifest-node">${nodeId}</span>
              <span class="manifest-status ${statusClass}">${statusText}</span>
              <span class="request-id">${data.requestId}</span>
              ${data.hash ? `<span class="manifest-hash">${data.hash}</span>` : ''}
            `;

          listEl.appendChild(li);
        });

        // Update heights after modifying content
        stageManager.updateExpandedSectionHeights();
      },

      // Process all requests data at once
      processRequestsData(requests) {
        const sortedRequests = [...requests].sort((a, b) => b.timestamp - a.timestamp);

        sortedRequests.forEach(request => {
          this.addRequestFromTracker(request);
        });

        // Explicitly start resources stage if there are requests
        if (sortedRequests.length > 0 && !stages['stage-resources'].started) {
          stageManager.updateStageStatus('stage-resources', 'running');
        }

        // Force table update
        this.updateRequestsTable();
        return sortedRequests;
      }
    };

    function fail(message) {
      console.error('Service worker error:', message);
      document.body.classList.remove('hidden');
      document.getElementById('spinner').classList.add('hidden');
      document.getElementById('description-text').innerHTML =
        '<span style="color: #FF4D4D; margin-right: 5px;">&#x2716;</span>Failed to load';
      requestTracker.addRequest('error', message, true);

      stageManager.updateStageStatus(
        'stage-sw-register', 'error', `<p>Service worker registration failed: ${message}</p>`);
    }

    function failNoViewer(message) {
      console.error('Service worker error:', message);
      document.body.classList.remove('hidden');
      document.getElementById('spinner').classList.add('hidden');
      document.getElementById('description-text').innerHTML =
        '<span style="color: #FF4D4D; margin-right: 5px;">&#x2716;</span>Failed to load';
    }

    const reloadAfterWallTimeNoViewer = function (initDate) {
      return function (delayMs) {
        const msSinceInit = Date.now() - initDate;
        const timeout = Math.max(0, delayMs - msSinceInit);
        setTimeout(() => {
          location.reload();
        }, timeout);
      };
    }(Date.now());

    const reloadAfterWallTime = function (initDate) {
      return function (delayMs) {
        const msSinceInit = Date.now() - initDate;
        const timeout = Math.max(0, delayMs - msSinceInit);
        if (readyToLoad && !hasRedirected) {
          setTimeout(() => {
            hasRedirected = true;
            const url = new URL(window.location.href);
            url.searchParams.delete('secure_viewer');
            window.location.href = url.toString();
          }, timeout);
        } else {
          if (!stages['stage-manifest'].started) {
            stageManager.updateStageStatus('stage-manifest', 'running');
          }

          if (!stages['stage-ready'].started) {
            stageManager.updateStageStatus('stage-ready', 'running');
          }
        }
      };
    }(Date.now());

    // Handler for stage-ready button (new)
    stageReadyButton.addEventListener('click', () => {
      if (!isSecureViewer) {
        readyToLoad = true;
        location.reload();
      } else {
        const url = new URL(window.location.href);
        url.searchParams.delete('secure_viewer');
        window.location.href = url.toString();
      }
    });

    window.addEventListener('load', () => {
      document.getElementById('domain').innerText = location.host;
      document.body.classList.remove('hidden');
      const stagesContainer = document.getElementById('stages-container');

      // Add event listeners for stage headers
      document.querySelectorAll('.stage-toggle-header').forEach(header => {
        header.addEventListener('click', () => {
          const stage = header.closest('.stage');
          stage.classList.toggle('expanded');

          const content = stage.querySelector('.stage-content');
          if (stage.classList.contains('expanded')) {
            content.style.height = 'auto';
          } else {
            content.style.height = '0';
          }
        });
      });

      if (isSecureViewer) {
        if (stagesContainer) {
          stagesContainer.style.display = 'block';
        }

        if (stageReadyButton) {
          stageReadyButton.disabled = true;
          stageReadyButton.style.opacity = '0';
          stageReadyButton.style.cursor = 'not-allowed';
        }

        const devToolsNotice = document.getElementById('dev-tools-notice');
        const startLoadingButton = document.getElementById('start-loading-button');
        devToolsNotice.classList.add('show');
        startLoadingButton.style.display = 'block';

        document.getElementById('spinner').style.display = 'none';

        startLoadingButton.addEventListener('click', () => {
          devToolsNotice.classList.remove('show');
          startLoadingButton.style.display = 'none';
          document.body.classList.remove('regular-flow');
          devToolsInstructions.style.display = 'block';
          initializeServiceWorker(true);
        });
      } else {
        if (stagesContainer) {
          stagesContainer.style.display = 'none';
        }
        initializeServiceWorker(false);
      }
    });

    const initializeServiceWorker = (isSecureViewerMode = false) => {
      if (isSecureViewerMode) {
        document.getElementById('spinner').style.display = 'block';
        stageManager.updateStageStatus('stage-manifest', 'running');
      }

      if (!('serviceWorker' in navigator)) {
        document.cookie = 'supportsSW=false; path=/';
        if (isSecureViewerMode) {
          fail('Service worker not supported by this browser');
        }
        window.location.reload();
        return;
      }

      navigator.serviceWorker.addEventListener('message', event => {
        const eventType = event.data.type ? event.data.type : event.data.action;
        const error = event.data.error || '';

        switch (eventType) {
          case 'INITIALIZED':
            if (event.data.nodes && event.data.nodes.length > 0) {
              const progressEl = document.getElementById('stage-manifest-progress');
              progressEl.innerHTML = `<div class="stage-progress-text">0/${event.data.nodes.length} nodes</div>`;

              const nodesListHtml = event.data.nodes
                .map(node => `<li class="manifest-item">
                  <span class="manifest-node">${node}</span>
                  <span class="manifest-status status-pending">Pending</span>
                </li>`).join('');

              document.getElementById('manifest-nodes-list').innerHTML = nodesListHtml;
            }

            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({ type: 'GET_ALL_REQUESTS' });
            }

            if (!isSecureViewer) {
              reloadAfterWallTimeNoViewer(0);
            }
            break;

          case 'VERSION_DETECTED':
          case 'VERSION_READY':
            if (isSecureViewerMode) {
              requestTracker.addRequest('info', `Service worker ${eventType.toLowerCase()}`);
            }
            break;

          case 'MANIFEST_FETCH_ERROR':
          case 'MANIFEST_FETCH_FAILURE_NO_CONSENSUS':
          case 'CONTENT_CHECKSUM_MISMATCH':
          case 'CONTENT_NODE_FETCH_FAILURE':
          case 'CONTENT_NODES_FETCH_FAILURE':
            if (isSecureViewerMode) {
              console.error(`${eventType}:`, error);
              requestTracker.addRequest('error', error, true);
              if (stages['stage-resources'].started && !stages['stage-resources'].completed) {
                stageManager.updateStageStatus('stage-resources', 'error', `<p>${error}</p>`);
              }
            }
            break;

          case 'REQUEST_TRACKED':
            if (isSecureViewerMode) {
              requestTracker.addRequestFromTracker(event.data.request);
              if (!stages['stage-resources'].started) {
                stageManager.updateStageStatus('stage-resources', 'running');
              }
              requestTracker.updateRequestsTable();
              stageManager.updateAllStages();
            }
            break;

          case 'ALL_REQUESTS':
            if (isSecureViewerMode) {
              requests = requests.filter(req => !req.isTrackedRequest);
              requestTracker.processRequestsData(event.data.requests);
            }
            break;

          case 'REQUESTS_CLEARED':
            if (isSecureViewerMode) {
              requests = requests.filter(req => !req.isTrackedRequest);
              requestTracker.updateRequestsLog();
            }
            break;

          case 'PRELOADING_COMPLETE':
            preloadingComplete = true;
            if (isSecureViewerMode) {
              stageManager.updateAllStages();
            } else {
              reloadAfterWallTimeNoViewer(0);
            }
            break;

          case 'PRELOADING_ERROR':
            preloadingComplete = true;
            if (isSecureViewerMode) {
              console.error('Preloading error:', event.data.error);
              stageManager.updateAllStages();
            }
            break;

          default:
            if (isSecureViewerMode && event.data.error) {
              requestTracker.addRequest('unknown', `Unknown error: ${event.data.error}`, true);
            }
        }
      });

      navigator.serviceWorker.register(serviceWorker, { scope: '/' })
        .then(reg => {
          if (isSecureViewerMode) {
            if (reg.active && navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({ type: 'GET_ALL_REQUESTS' });
              reloadAfterWallTime(0);
            } else {
              if (showSpinner) {
                document.body.classList.remove('hidden');
              }

              reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'activated') {
                    reloadAfterWallTime(500);
                  }
                });
              });
            }
          } else {
            if (reg.active) {
              reloadAfterWallTimeNoViewer(0);
            } else {
              if (showSpinner) {
                document.body.classList.remove('hidden');
              }
              reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'activated') {
                    reloadAfterWallTimeNoViewer(500);
                  }
                });
              });
            }
          }
        })
        .catch(err => {
          if (isSecureViewerMode) {
            fail('Service worker registration failed: ' + err);
          } else {
            failNoViewer('Service worker registration failed: ' + err);
          }
        });
    };

  </script>
</body>

</html>
